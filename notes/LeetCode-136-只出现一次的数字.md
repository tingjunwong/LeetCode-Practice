

# **From** 
1. [single number](https://leetcode-cn.com/problems/single-number)

<!-- more -->
# **Problem**
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4


```

// 因为题目要求是   时间复杂度是  O（n), 空间复杂度 是 O（1）， 

class Solution {
    public int singleNumber(int[] nums) {

//基本思路是 遍历 nums的每个元素，  如果某个nums中的数字是新出现的， 之前列表中没有， 就添加到列表中；
// 如果nums中的某个数字已经在列表中，， 就将它删除， 因为   除去 只有1个数字出现一次之外， 其余数字都是出现2次，所以当其余数字出现第二次时， 即表示不是那个目标数字
for (int i = 0; i < nums.length; i ++) {

}

        
    }
}



// 看到  题解中 有人使用  异或运算，  是这样写的

int ans = nums[0];
if (nums.length > 1) {
	for (int i = 1; i < nums.length; i ++) {
		ans = ans ^ nums[i];
	}
}
return ans;


相同的元素 异或为0 ， n ^ n = 0   一个数字 和 其本身做异或运算， 等于0

一个数字和0 做异或运算 等于本身   a ^ 0 = a

异或 运算 满足 交换律和结合律，   a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b 


将所有 的数字按照 顺序做异或运算， 最后剩下的结果 为唯一的数字， 



class solution {
	public int singleNumber(int[] nums) {
		int ans = 0;
		for (int num : nums) {
			ans ^= num;
		}
		return ans;
	}
}






在CSDN 上看了一些大牛位运算的过程，表示 它的移位过程(可以通过其结果换算成二进制进行对比)：

首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):


5 << 2
0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：

0000 0000 0000 0000 0000 0000 0001 0100           换算成10进制为20

5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101



5 >> 2
0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：

0000 0000 0000 0000 0000 0000 0000 0001


1.    5 >> 3 表示 低3位舍弃， 高3位补0

5右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000        // (用0进行补位)



 -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011



2.   -5 >> 3 表示 低3位舍弃，高3位补1

-5右移3位后结果为-1，-1的二进制为： 1111 1111 1111 1111 1111 1111 1111 1111   // (用1进行补位)


3.    -5 >>> 3 表示 低3位 舍弃， 高3位补0 
-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111   // (用0进行补位)
————————————————
版权声明：本文为CSDN博主「Ely」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xiaochunyong/article/details/7748713

通过其结果转换成二进制后，我们可以发现，正数右移，高位用0补，负数右移，高位用1补，当负数使用无符号右移时，用0进行补位(自然而然的，就由负数变成了正数了)

注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。(自行测试)




```



& 1    最后一位前 全变为0，只保留原来的最后一位。   可以用来判断最后一位  是否为1   可以  X & 1 == 1   如果 true , 就为1


经常与右移 >> / >>> 配合使用，   这样可以检测 二进制数的任何一位 是否为 1 或 0 


比如说 if（X >> 4 & 1 == 1）  判断  从右往左 第4位  （从第0位开始）  是否为 1 


| 1    最后一位前面不变， 最后一位 变为 1 ，        可以用来 


同时需要注意 ， 有一个 变量x，  如果 x >> a, 或者 x << b， a,b 为任意常数， 都是不改变 x与y的值的， 所以

循环中每次移位， 下次移位 都是重新从原来的数 开始， 不会保留记录。
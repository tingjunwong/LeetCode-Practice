---
title: LeetCode-4-寻找两个有序数组中位数
tags:
  - LeetCode
categories:
  - LeetCode
abbrlink: bd5ba4a5
date: 2020-01-14 11:22:39
---
# **From** 
1. [median of two sorted arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/comments/)

<!-- more -->
# **Problem**
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

```


示例 2:

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

```

找出两个升序数组归并之后的中位数, 中位数 将一个升序数组 分成了 长度相等的两部分， 左半部分的 最大值  小于右半部分的 最小值


## solution：

1. 暴力枚举法 brutal force


    必须 将两个数组 归并为一个 大数组， 即创建一个新数组， 长度为 之前两个数组之和， 


2. 二分搜索法

    大数组被中位数等分的左右两部分，每一部分根据来源又可以再划分成两部分，

    其中一部分来自数组A的元素，另一部分来自数组B的元素：



    i) 长度为奇数的数组：
        若除去中位数，两端长度相等， 
        假设 中位数放在左半部分， 左半部分长度 = 右半部分长度 +

    假设数组A的长度是m，绿色和橙色元素的分界点是i，数组B的长度是n，绿色和橙色元素的分界点是j，那么为了让大数组的左右两部分长度相等，则i和j需要符合如下两个条件：



i + j = （m+n+1）/2

（之所以m+n后面要再加1，是为了应对大数组长度为奇数的情况）



Max(A[i-1],B[j-1]) < Min(A[i], B[j])

(直白的说，就是最大的绿色元素小于最小的橙色元素)



由于m+n的值是恒定的，所以我们只要确定一个合适的i，就可以确定j，从而找到大数组左半部分和右半部分的分界，也就找到了归并之后大数组的中位数





